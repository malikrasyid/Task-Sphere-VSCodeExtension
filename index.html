<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Task Manager</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link href="https://cdn.jsdelivr.net/npm/fullcalendar@5.10.1/main.min.css" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/fullcalendar@5.10.1/main.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
</head>
<body class="bg-gray-50 text-gray-800 min-h-screen">
    <div class="bg-white shadow-sm border-b border-gray-200">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between items-center h-16">
                <div class="flex items-center space-x-2">
                    <div class="w-8 h-8 rounded-md bg-gradient-to-br from-blue-600 to-indigo-600 flex items-center justify-center text-white font-bold text-xl">T</div>                    
                    <h1 class="text-2xl font-bold text-indigo-600">Task Sphere</h1>
                </div>
                <div class="flex items-center space-x-4">
                    <!-- Connection Status -->
                    <div class="flex items-center">
                        <div class="relative">
                            <div id="connectionStatus" class="flex items-center px-3 py-1 rounded-full text-white text-sm font-medium">
                                <span id="statusDot" class="h-2 w-2 rounded-full mr-2"></span>
                                <span id="statusText">Offline</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Sync Button -->
                    <button id="syncButton" class="btn btn-primary inline-flex items-center">
                        <i class="fas fa-sync-alt mr-2"></i>
                        <span>Sync</span>
                    </button>
                    <div class="relative" id="userMenuContainer">
                        <button id="loginButton" onclick="openLoginModal()" class="btn btn-secondary inline-flex items-center">
                            <i class="fas fa-user mr-2"></i>
                            <span>Login</span>
                        </button>
                        
                        <!-- User status will be shown here when logged in -->
                        <div id="userStatusContainer" class="hidden ml-3">
                            <div class="flex items-center space-x-3">
                                <div class="relative group">
                                    <div class="h-8 w-8 rounded-full bg-indigo-600 flex items-center justify-center text-white cursor-pointer hover:bg-indigo-700 transition-colors">
                                        <span id="userInitials">--</span>
                                    </div>
                                    <!-- Dropdown menu -->
                                    <div class="absolute right-0 mt-2 w-48 bg-white rounded-md shadow-lg py-1 z-50 hidden group-hover:block">
                                        <div class="px-4 py-2 border-b border-gray-100">
                                            <p id="userStatus" class="text-sm font-medium text-gray-700">Not logged in</p>
                                            <p class="text-xs text-gray-500" id="accountType">Free Account</p>
                                        </div>
                                        <a href="https://task-sphere-web.vercel.app/" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-50">
                                            <i class="fas fa-external-link-alt mr-2"></i>
                                            Go to Web App
                                        </a>
                                        <button onclick="logout()" class="w-full text-left px-4 py-2 text-sm text-red-600 hover:bg-red-50 flex items-center">
                                            <i class="fas fa-sign-out-alt mr-2"></i>
                                            Logout
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>  
                </div>
            </div>
        </div>
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6">
        <div class="container mx-auto p-4 space-y-6">
            <div id="calendarView" class="view">
                <div id="calendar" class="my-4"></div>
            </div>
            <div id="tasksView" class="view">
                <h2 class="text-2xl font-semibold mb-4">Task List</h2>
                <div id="tasksContainer" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4"></div>
            </div>
        </div>
    </div>

    <!-- Login Modal -->
    <div id="loginModal" class="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center hidden z-50">
        <div class="bg-white p-6 rounded-lg shadow-lg max-w-md w-full">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-xl font-semibold text-gray-800">Sign in to your account</h2>
                <button onclick="closeLoginModal()" class="text-gray-400 hover:text-gray-500">
                    <i class="fas fa-times"></i>
                </button>
            </div>           
            <div class="space-y-4">
                <div>
                    <label for="emailInput" class="block text-sm font-medium text-gray-700">Email</label>
                    <input id="emailInput" type="email" placeholder="Enter your email" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                </div>               
                <div>
                    <label for="passwordInput" class="block text-sm font-medium text-gray-700">Password</label>
                    <input id="passwordInput" type="password" placeholder="Enter your password" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                </div>
                <div class="flex items-center justify-between">
                    <div class="flex items-center">
                        <input id="remember-me" type="checkbox" class="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded">
                        <label for="remember-me" class="ml-2 block text-sm text-gray-700">Remember me</label>
                    </div>
                    <div class="text-sm">
                        <a href="#" class="font-medium text-indigo-600 hover:text-indigo-500">Forgot password?</a>
                    </div>
                </div>
                <div class="flex justify-end mt-6 space-x-3">
                    <button onclick="closeLoginModal()" class="btn btn-secondary">Cancel</button>
                    <button onclick="loginUser()" class="btn btn-primary">Sign in</button>
                </div>
            </div>
        </div>
    </div>
    <script>
        // Global variables
        let socket;
        let projectsSocket;
        let tasksSocket;
        let usersSocket;
        let commentsSocket;
        let notificationsSocket;
        let localTasks = JSON.parse(localStorage.getItem("tasks")) || [];
        let authToken = localStorage.getItem("sessionToken");
        let currentUser = localStorage.getItem("userId");
        let calendar;
        let isOffline = true;
        const apiUrl = "https://task-sphere-pi.vercel.app";
        const wsUrl = "wss://websocket-task-sphere-production.up.railway.app";
        let isWebviewDisposed = false;

        // Handle webview messages
        window.addEventListener('message', event => {
            const message = event.data;
            switch (message.command) {
                case 'webviewDisposed':
                    isWebviewDisposed = true;
                    // Clean up resources
                    if (socket) socket.close();
                    if (projectsSocket) projectsSocket.close();
                    if (tasksSocket) tasksSocket.close();
                    if (usersSocket) usersSocket.close();
                    if (commentsSocket) commentsSocket.close();
                    if (notificationsSocket) notificationsSocket.close();
                    break;
                case 'webviewReady':
                    isWebviewDisposed = false;
                    // Reinitialize if needed
                    initializeApp();
                    break;
            }
        });

        // Function to safely show VS Code notifications
        function showVSCodeNotification(message) {
            if (!isWebviewDisposed && window.vsCodeApi) {
                try {
                    window.vsCodeApi.postMessage({
                        command: 'showWarning',
                        text: message
                    });
                } catch (error) {
                    console.error('Failed to show VS Code notification:', error);
                }
            }
        }

        // Function to initialize the app
        function initializeApp() {
            if (isWebviewDisposed) return;

            // Initialize UI elements
            connectionStatus = document.getElementById("connectionStatus");
            statusDot = document.getElementById("statusDot");
            statusText = document.getElementById("statusText");
            syncButton = document.getElementById("syncButton");
            tasksContainer = document.getElementById("tasksContainer");
            userStatus = document.getElementById("userStatus");
            userInitials = document.getElementById("userInitials");
            loginButton = document.getElementById("loginButton");
            userStatusContainer = document.getElementById("userStatusContainer");
            accountType = document.getElementById("accountType");
            calendarTab = document.getElementById("calendarTab");
            tasksTab = document.getElementById("tasksTab");

            // Set initial states
            updateConnectionStatus(false);
            loadLocalData();
            updateUserStatus();
            updateSyncButtonState();
            
            if (calendar) {
                renderCalendar();
            }

            // Start auto-update and deadline checking
            checkAndUpdateTaskStatuses();
            startDeadlineChecking();

            // Set up periodic status checks (every 5 minutes)
            setInterval(checkAndUpdateTaskStatuses, 5 * 60 * 1000);

            // Add event listeners
            syncButton.addEventListener('click', async () => {
                await syncTasks();
            });
        }

        // Modify checkDeadlines to use safe notification
        function checkDeadlines() {
            if (isWebviewDisposed) return;
            
            const now = new Date();
            for (const task of localTasks) {
                if (task.status === 'Done' || !task.endDate) continue;
                const endDate = new Date(task.endDate);
                const timeDiff = endDate - now;
                
                if (timeDiff > 0 && timeDiff <= 60 * 60 * 1000) {
                    showVSCodeNotification(`Task "${task.name}" is due in less than an hour!`);
                    showNotification(
                        "Upcoming Deadline",
                        `Task "${task.name}" is due in less than an hour!`,
                        "warning"
                    );
                }
            }
        }

        // Initialize the app
        document.addEventListener("DOMContentLoaded", () => {
            // Notify VS Code that webview is ready
            if (window.vsCodeApi) {
                window.vsCodeApi.postMessage({ command: 'webviewReady' });
            }
            
            initializeApp();
        });

        // Clean up when window is unloaded
        window.addEventListener('unload', () => {
            if (window.vsCodeApi) {
                window.vsCodeApi.postMessage({ command: 'webviewDisposed' });
            }
        });

        // Auto status update functionality
        const getAutoStatus = (startDate, endDate) => {
            // Get current time in UTC
            if (!startDate || !endDate) return 'Not Started'
            
            const now = new Date()
            
            // Ensure UTC parsing by adding Z if not present
            const startUTC = startDate.includes('Z') || startDate.includes('+') ? startDate : startDate + 'Z'
            const endUTC = endDate.includes('Z') || endDate.includes('+') ? endDate : endDate + 'Z'
            
            const start = new Date(startUTC)
            const end = new Date(endUTC)
            
            // Log for debugging
            console.log('Date comparison:', {
                now: now.toISOString(),
                start: start.toISOString(),
                end: end.toISOString(),
                startLocal: start.toLocaleString(),
                endLocal: end.toLocaleString(),
                nowTime: now.getTime(),
                startTime: start.getTime(),
                endTime: end.getTime(),
                isBeforeStart: now < start,
                isAfterEnd: now > end
            })
            
            if (isNaN(start.getTime()) || isNaN(end.getTime())) {
                console.error('Invalid date detected:', { startDate, endDate })
                return 'Not Started'
            }
            
            if (now < start) {
                console.log('Status: Not Started (now < start)')
                return 'Not Started'
            } else if (now > end) {
                console.log('Status: Overdue (now > end)')
                return 'Overdue'
            } else {
                console.log('Status: Ongoing (start <= now <= end)')
                return 'Ongoing'
            }
        }

        // Function to sync task status
        async function syncTask(projectId, taskId, newStatus) {
            try {
                const task = localTasks.find(t => t.projectId === projectId && t.taskId === taskId);
                if (!task) {
                    throw new Error('Task not found');
                }

                // If online, try to update server first
                if (!isOffline) {
                    const response = await fetch(`${apiUrl}/api/projects/tasks?projectId=${projectId}&&taskId=${taskId}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${localStorage.getItem("sessionToken")}`
                        },
                        body: JSON.stringify({ status: newStatus })
                    });

                    if (!response.ok) {
                        throw new Error('Failed to update task status on server');
                    }

                    // Only update locally if server update was successful
                    task.status = newStatus;
                    saveToLocalStorage(localTasks);
                    updateTaskList(localTasks);
                    renderCalendar();
                } else {
                    // If offline, update locally and queue for sync
                    task.status = newStatus;
                    saveToLocalStorage(localTasks);
                    updateTaskList(localTasks);
                    renderCalendar();
                    handleOfflineChange('task_update', { projectId, taskId, status: newStatus });
                }
            } catch (error) {
                console.error('Error syncing task status:', error);
                showNotification("Error", "Failed to sync task status", "error");
            }
        }

        // Function to check and update task statuses
        async function checkAndUpdateTaskStatuses() {
            for (const task of localTasks) {
                if (task.status === 'Done') continue; // Skip completed tasks
                
                const newStatus = getAutoStatus(task.startDate, task.endDate);
                if (newStatus !== task.status) {
                    await syncTask(task.projectId, task.taskId, newStatus);
                }
            }
        }

        // Function to start deadline checking
        function startDeadlineChecking() {
            // Check deadlines immediately
            checkDeadlines();
            
            // Then check every hour
            setInterval(checkDeadlines, 60 * 60 * 1000);
        }

        // Improve task detail modal
        function showTaskDetails(task) {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50';
            modal.innerHTML = `
                <div class="relative mx-auto p-5 border w-full max-w-md shadow-lg rounded-md bg-white">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-lg font-medium text-gray-800">Task Details</h3>
                        <button class="text-gray-400 hover:text-gray-500 close-modal">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div class="space-y-4">
                        <div>
                            <h4 class="text-sm font-medium text-gray-500">Task Name</h4>
                            <p class="mt-1 text-gray-900">${task.name}</p>
                        </div>
                        <div>
                            <h4 class="text-sm font-medium text-gray-500">Project</h4>
                            <p class="mt-1 text-gray-900">${task.projectName || 'N/A'}</p>
                        </div>
                        <div>
                            <h4 class="text-sm font-medium text-gray-500">Status</h4>
                            <p class="mt-1">
                                <span class="px-2 py-1 rounded text-white text-xs" 
                                    style="background-color: ${getTaskColor(task.status)}">${task.status}</span>
                            </p>
                        </div>
                        ${task.deliverable ? `
                            <div>
                                <h4 class="text-sm font-medium text-gray-500">Deliverable</h4>
                                <p class="mt-1 text-gray-900">${task.deliverable}</p>
                            </div>
                        ` : ''}
                        <div>
                            <h4 class="text-sm font-medium text-gray-500">Start Date</h4>
                            <p class="mt-1 text-gray-900">${formatDateUTC(task.startDate)}</p>
                        </div>
                        <div>
                            <h4 class="text-sm font-medium text-gray-500">End Date</h4>
                            <p class="mt-1 text-gray-900">${formatDateUTC(task.endDate)}</p>
                        </div>
                    </div>
                    <div class="mt-6 flex justify-end space-x-3">
                        ${task.status !== 'Done' ? 
                            `<button onclick="markAsDone('${task.projectId}', '${task.taskId}')" 
                                    class="btn btn-success">
                                <i class="fas fa-check mr-1"></i> Mark Done
                            </button>` : ''}
                        <button onclick="deleteTask('${task.projectId}', '${task.taskId}')" 
                                class="btn btn-danger">
                            <i class="fas fa-trash-alt mr-1"></i> Delete
                        </button>
                        <button class="btn btn-secondary close-modal">Close</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            modal.addEventListener('click', function(e) {
                if (e.target === modal || e.target.classList.contains('close-modal')) {
                    modal.remove();
                }
            });
        }

    // Update sync button state
    function updateSyncButtonState() {
        if (!currentUser) {
            syncButton.disabled = true;
            syncButton.classList.add('opacity-50', 'cursor-not-allowed');
        } else {
            syncButton.disabled = false;
            syncButton.classList.remove('opacity-50', 'cursor-not-allowed');
        }
    }

    function updateConnectionStatus(isConnected) {
        isOffline = !isConnected;
        
        if (isConnected) {
            connectionStatus.className = "flex items-center px-3 py-1 rounded-full bg-emerald-100 text-emerald-800 text-sm font-medium";
            statusDot.className = "h-2 w-2 rounded-full mr-2 bg-emerald-500";
            statusText.textContent = "Online";
        } else {
            connectionStatus.className = "flex items-center px-3 py-1 rounded-full bg-red-100 text-red-800 text-sm font-medium";
            statusDot.className = "h-2 w-2 rounded-full mr-2 bg-red-500 pulse";
            statusText.textContent = "Offline";
        }
    }

    // Load data from local storage
    function loadLocalData() {
        const storedTasks = localStorage.getItem("tasks");
        if (storedTasks) {
            localTasks = JSON.parse(storedTasks);
            updateTaskList(localTasks);
            renderCalendar(); // Always render calendar when loading local data
        }
    }

    // Save data to local storage
    function saveToLocalStorage(tasks) {
        localStorage.setItem("tasks", JSON.stringify(tasks));
        localTasks = tasks;
    }

    // Handle offline changes
    function handleOfflineChange(changeType, data) {
        const offlineChanges = JSON.parse(localStorage.getItem("offlineChanges") || "[]");
        offlineChanges.push({
            type: changeType,
            data: data,
            timestamp: new Date().toISOString()
        });
        localStorage.setItem("offlineChanges", JSON.stringify(offlineChanges));
    }

    // Sync offline changes when coming back online
    async function syncOfflineChanges() {
        const offlineChanges = JSON.parse(localStorage.getItem("offlineChanges") || "[]");
        if (offlineChanges.length === 0) return;

        for (const change of offlineChanges) {
            try {
                switch (change.type) {
                    case 'task_update':
                        await updateTaskOnServer(change.data);
                        break;
                    case 'task_delete':
                        await deleteTaskOnServer(change.data.projectId, change.data.taskId);
                        break;
                    // Add other change types as needed
                }
            } catch (error) {
                console.error('Failed to sync change:', error);
                // Keep the change in offlineChanges if it failed
                continue;
            }
        }

        // Clear synced changes
        localStorage.setItem("offlineChanges", "[]");
    }

    async function updateTaskOnServer(taskData) {
        const response = await fetch(`${apiUrl}/api/projects/tasks?projectId=${taskData.projectId}&&taskId=${taskData.taskId}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${localStorage.getItem("sessionToken")}`
            },
            body: JSON.stringify(taskData)
        });
        return response.ok;
    }

    async function deleteTaskOnServer(projectId, taskId) {
        const response = await fetch(`${apiUrl}/api/projects/tasks?projectId=${projectId}&&taskId=${taskId}`, {
            method: 'DELETE',
            headers: {
                'Authorization': `Bearer ${localStorage.getItem("sessionToken")}`
            }
        });
        return response.ok;
    }

    function formatDateUTC(date) {
        if (!date) return 'N/A';
        return new Date(date).toLocaleString('en-GB', {
            day: '2-digit',
            month: 'short',
            year: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
            timeZone: 'UTC',
            timeZoneName: 'short'
        });
    }

    function handleSessionExpired() {
        // Clear all local storage
        localStorage.removeItem("sessionToken");
        localStorage.removeItem("userId");
        localStorage.removeItem("userEmail");
        localStorage.removeItem("tasks");
        
        // Close all socket connections
        if (socket) socket.close();
        if (projectsSocket) projectsSocket.close();
        if (tasksSocket) tasksSocket.close();
        if (notificationsSocket) notificationsSocket.close();
        
        // Update UI
        updateUserStatus();
        
        // Show notification
        showNotification("Session Expired", "Your session has expired. Please login again.", "warning");
        
        // Clear tasks and calendar
        localTasks = [];
        updateTaskList(localTasks);
        if (calendar) {
            calendar.removeAllEvents();
        }
        
        // Open login modal
        openLoginModal();
    }

    function showNotification(title, message, type = "info") {
        // Create notification element
        const notification = document.createElement("div");
        notification.className = "fixed top-4 right-4 p-4 rounded-lg shadow-lg z-50 flex items-start space-x-4 max-w-sm transform transition-all duration-300 translate-y-0 opacity-100";
        
        // Set background color based on type
        switch(type) {
            case "success":
                notification.classList.add("bg-emerald-100", "border-l-4", "border-emerald-500", "text-emerald-700");
                break;
            case "error":
                notification.classList.add("bg-red-100", "border-l-4", "border-red-500", "text-red-700");
                break;
            case "warning":
                notification.classList.add("bg-yellow-100", "border-l-4", "border-yellow-500", "text-yellow-700");
                break;
            default:
                notification.classList.add("bg-blue-100", "border-l-4", "border-blue-500", "text-blue-700");
        }
        
        // Create icon based on type
        let icon;
        switch(type) {
            case "success":
                icon = '<i class="fas fa-check-circle text-emerald-500 text-xl"></i>';
                break;
            case "error":
                icon = '<i class="fas fa-exclamation-circle text-red-500 text-xl"></i>';
                break;
            case "warning":
                icon = '<i class="fas fa-exclamation-triangle text-yellow-500 text-xl"></i>';
                break;
            default:
                icon = '<i class="fas fa-info-circle text-blue-500 text-xl"></i>';
        }
        
        notification.innerHTML = `
            <div class="flex-shrink-0">${icon}</div>
            <div class="flex-1">
                <h4 class="text-sm font-medium">${title}</h4>
                <p class="mt-1 text-sm">${message}</p>
            </div>
            <button class="flex-shrink-0 text-gray-400 hover:text-gray-500">
                <i class="fas fa-times"></i>
            </button>
        `;
        
        document.body.appendChild(notification);
        
        // Add event listener to close button
        notification.querySelector("button").addEventListener("click", () => {
            notification.classList.replace("translate-y-0", "-translate-y-12");
            notification.classList.replace("opacity-100", "opacity-0");
            setTimeout(() => notification.remove(), 300);
        });
        
        // Auto-dismiss after 5 seconds
        setTimeout(() => {
            if (document.body.contains(notification)) {
                notification.classList.replace("translate-y-0", "-translate-y-12");
                notification.classList.replace("opacity-100", "opacity-0");
                setTimeout(() => notification.remove(), 300);
            }
        }, 5000);
    }

    function closeLoginModal() {
        document.getElementById("loginModal").classList.add("hidden");
    }

    async function updateUserStatus() {
        const userEmail = localStorage.getItem("userEmail");
        const hasUser = !!userEmail;
        
        if (hasUser) {
            // Get user details from server or use stored details
            let userName = await fetchUserById(localStorage.getItem("userId")) || userEmail;
            
            // Update UI for logged in state
            loginButton.classList.add("hidden");
            userStatusContainer.classList.remove("hidden");
            
            userStatus.textContent = userName;
            
            // Set user initials (first letter of first and last name)
            const nameParts = userName.split(" ");
            let initials = nameParts[0][0].toUpperCase();
            if (nameParts.length > 1) {
                initials += nameParts[nameParts.length - 1][0].toUpperCase();
            }
            userInitials.textContent = initials;
            
            // Update account type (could be fetched from server in a real app)
            accountType.textContent = "Pro Account";
        } else {
            // Update UI for logged out state  
            loginButton.classList.remove("hidden");
            userStatusContainer.classList.add("hidden");
            userStatus.textContent = "Not logged in";
            userInitials.textContent = "--";
            accountType.textContent = "Free Account";
        }
    }
        
    function getTaskColor(status) {
        switch (status) {
            case "Done": return "#10B981"; // green-500
            case "Ongoing": return "#3B82F6"; // blue-500
            case "Overdue": return "#EF4444"; // red-500
            case "Not Started": return "#6B7280"; // gray-500
            default: return "#9CA3AF"; // gray-400
        }
    }

    async function fetchUserById(userId) {
        const token = localStorage.getItem("sessionToken");

        try {
            const res = await fetch(`${apiUrl}/api/users?action=name&userId=${encodeURIComponent(userId)}`, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
            }
        });
            if (!res.ok) throw new Error('User not found');
            const data = await res.json();
            return data.name || userId;
        } catch (err) {
            console.error('Failed to fetch user by ID:', err);
            return userId;
        }
    }

    async function syncTasks() {
        try {
            // Show loading state on sync button
            syncButton.disabled = true;
            syncButton.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i><span>Syncing...</span>';

            const token = localStorage.getItem("sessionToken");
            if (!token) {
                showNotification("Sync failed", "Please login first", "warning");
                return;
            }

            // Fetch tasks from server
            const projects = await fetchUserProjects();
            if (!projects || projects.length === 0) {
                showNotification("Sync warning", "No projects found", "warning");
                return;
            }

            let allTasks = [];
            let syncErrors = [];
            
            // Fetch tasks for each project
            for (const project of projects) {
                try {
                    const tasks = await fetchProjectTasks(project.projectId);
                    if (tasks && tasks.length > 0) {
                        const tasksWithProject = tasks.map(task => ({
                            ...task,
                            projectName: project.name,
                            projectId: project.projectId
                        }));
                        allTasks = [...allTasks, ...tasksWithProject];
                    }
                } catch (err) {
                    console.error(`Error fetching tasks for project ${project.projectId}:`, err);
                    syncErrors.push(`Failed to sync project: ${project.name}`);
                }
            }
            
            // Update local storage with new tasks
            if (allTasks.length > 0) {
                saveToLocalStorage(allTasks);
                updateTaskList(allTasks);
                renderCalendar();
                console.log(`Synced ${allTasks.length} tasks from server`);
            }

            // Sync any offline changes
            const offlineChanges = JSON.parse(localStorage.getItem("offlineChanges") || "[]");
            if (offlineChanges.length > 0) {
                console.log(`Syncing ${offlineChanges.length} offline changes`);
                await syncOfflineChanges();
            }

            // Update connection status
            updateConnectionStatus(true);

            // Show appropriate notification
            if (syncErrors.length > 0) {
                showNotification(
                    "Sync completed with warnings", 
                    `${allTasks.length} tasks synced, but ${syncErrors.length} projects failed to sync`, 
                    "warning"
                );
            } else {
                showNotification(
                    "Sync complete", 
                    `${allTasks.length} tasks synchronized successfully`, 
                    "success"
                );
            }
        } catch (error) {
            console.error("Sync failed:", error);
            updateConnectionStatus(false);
            showNotification("Sync failed", "Could not connect to server", "error");
        } finally {
            // Reset sync button
            syncButton.disabled = false;
            syncButton.innerHTML = '<i class="fas fa-sync-alt mr-2"></i><span>Sync</span>';
        }
    }

    async function fetchUserProjects() {
        const token = localStorage.getItem("sessionToken");
        
        try {
            const response = await fetch(`${apiUrl}/api/projects`, {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${token}`
                }
            });

            if (response.status === 401) {
                handleSessionExpired();
                return null;
            }

            if (!response.ok) {
                throw new Error(`Server responded with status: ${response.status}`);
            }

            const data = await response.json();
            return data.projects || [];
        } catch (error) {
            console.error('Error fetching projects:', error);
            throw error;
        }
    }

    async function fetchProjectTasks(projectId) {
        const token = localStorage.getItem("sessionToken");

        try {
            const response = await fetch(`${apiUrl}/api/projects/tasks?projectId=${projectId}`, {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${token}`
                }
            });

            if (response.status === 401) {
                handleSessionExpired();
                return null;
            }

            if (!response.ok) {
                throw new Error(`Server responded with status: ${response.status}`);
            }

            const data = await response.json();
            if (!data.tasks) {
                return [];
            }

            // Convert Firestore timestamps to ISO strings
            return data.tasks.map(task => ({
                ...task,
                startDate: task.startDate ? new Date(task.startDate._seconds * 1000).toISOString() : null,
                endDate: task.endDate ? new Date(task.endDate._seconds * 1000).toISOString() : null
            }));
        } catch (error) {
            console.error('Error fetching tasks:', error);
            throw error;
        }
    }

    function updateTaskList(tasks) {
        if (!tasksContainer) return;
        
        // Clear existing tasks
        tasksContainer.innerHTML = "";
        
        if (tasks.length === 0) {
            tasksContainer.innerHTML = `
                <div class="col-span-3 flex flex-col items-center justify-center py-12">
                    <div class="text-center">
                        <i class="fas fa-clipboard-list text-gray-300 text-5xl mb-4"></i>
                        <h3 class="text-xl font-medium text-gray-700 mb-2">No tasks available</h3>
                        <p class="text-gray-500 mb-4">You haven't created any tasks yet.</p>
                        <a href="https://task-sphere-web.vercel.app/" class="btn btn-primary">
                            <i class="fas fa-plus mr-2"></i> Create Task
                        </a>
                    </div>
                </div>
            `;            
            return;
        }
        
        // Add tasks to container
        tasks.forEach(task => {
            const taskCard = document.createElement("div");
            taskCard.className = "task-card bg-white rounded-lg shadow border border-gray-100 overflow-hidden hover:shadow-md transition-shadow";
            
            // Calculate task progress (if applicable)
            const now = new Date();
            const startDate = task.startDate ? new Date(task.startDate) : null;
            const endDate = task.endDate ? new Date(task.endDate) : null;
            
            let progressPercentage = 0;
            let progressDisplay = '';
            
            if (startDate && endDate && task.status !== 'Done') {
                const totalDuration = endDate - startDate;
                const elapsedDuration = now - startDate;
                progressPercentage = Math.min(Math.max(Math.round((elapsedDuration / totalDuration) * 100), 0), 100);
                
                progressDisplay = `
                    <div class="mt-2">
                        <div class="w-full bg-gray-200 rounded-full h-1.5">
                            <div class="bg-blue-500 h-1.5 rounded-full" style="width: ${progressPercentage}%"></div>
                        </div>
                        <div class="text-xs text-gray-500 mt-1 text-right">${progressPercentage}% complete</div>
                    </div>
                `;
            }
            
            taskCard.innerHTML = `
                <div class="p-4">
                    <div class="flex justify-between items-start mb-3">
                        <h3 class="font-semibold text-gray-800">${task.name}</h3>
                        <span class="px-2 py-1 rounded text-white text-xs" 
                            style="background-color: ${getTaskColor(task.status)}">${task.status}</span>
                    </div>
                
                    <div class="space-y-2 mb-3">
                        <div class="flex items-center text-sm text-gray-600">
                            <i class="fas fa-folder-open mr-2 text-indigo-500"></i>
                            <span>${task.projectName || 'N/A'}</span>
                        </div>
                            
                        ${task.deliverable ? `
                            <div class="flex items-center text-sm text-gray-600">
                                <i class="fas fa-file-alt mr-2 text-indigo-500"></i>
                                <span>${task.deliverable}</span>
                            </div>
                        ` : ''}
                            
                        <div class="flex items-center text-sm text-gray-600">
                            <i class="far fa-calendar-alt mr-2 text-indigo-500"></i>
                            <span>${formatDateUTC(task.startDate)}</span>
                        </div>
                        
                        <div class="flex items-center text-sm text-gray-600">
                            <i class="far fa-calendar-check mr-2 text-indigo-500"></i>
                            <span>${formatDateUTC(task.endDate)}</span>
                        </div>
                    </div>
                    
                    ${progressDisplay}
                </div>
                
                <div class="bg-gray-50 px-4 py-3 border-t border-gray-100 flex justify-end space-x-2">
                    ${task.status !== 'Done' ? 
                      `<button onclick="markAsDone('${task.projectId}', '${task.taskId}')" 
                               class="btn btn-sm btn-success">
                            <i class="fas fa-check mr-1"></i> Mark Done
                        </button>` : ''}
                    <button onclick="deleteTask('${task.projectId}', '${task.taskId}')" 
                            class="btn btn-sm btn-danger">
                        <i class="fas fa-trash-alt mr-1"></i> Delete
                    </button>
                </div>
            `;
            tasksContainer.appendChild(taskCard);
        });
    }
    
    async function renderCalendar() {
        const calendarEl = document.getElementById('calendar');
        if (!calendarEl) return;

        // Destroy existing calendar instance if it exists
        if (calendarEl._calendar) {
            calendarEl._calendar.destroy();
        }

        try {
            // Use local tasks for calendar events
            let allEvents = localTasks.map(task => ({
                id: task.taskId,
                title: task.name,
                start: task.startDate,
                end: task.endDate,
                backgroundColor: getTaskColor(task.status),
                borderColor: getTaskColor(task.status),
                extendedProps: {
                    projectName: task.projectName || 'N/A',
                    status: task.status,
                    deliverable: task.deliverable || 'N/A',
                    projectId: task.projectId
                }
            }));

            calendar = new FullCalendar.Calendar(calendarEl, {
                initialView: 'dayGridMonth',
                headerToolbar: {
                    left: 'prev,next today',
                    center: 'title',
                    right: 'dayGridMonth,timeGridWeek,timeGridDay'
                },
                events: allEvents,
                eventDidMount: function(info) {
                    info.el.title = `
                        Project: ${info.event.extendedProps.projectName}
                        Status: ${info.event.extendedProps.status}
                    `.trim();
                },
                eventClick: function(info) {
                    const event = info.event;
                    const task = localTasks.find(t => t.taskId === event.id);
                    if (task) {
                        showTaskDetails(task);
                    }
                },
                height: 'auto'
            });
            calendar.render();
            calendarEl._calendar = calendar;
        
        } catch (error) {
            console.error('Error rendering calendar:', error);
            calendarEl.innerHTML = '<p class="text-red-500 p-4">Error loading calendar. Please try again later.</p>';
        }
    }
       
    // Initialize Socket.IO connections
    function initializeSocketIO() {
        const userId = localStorage.getItem('userId');
        if (!userId) {
            console.error('Cannot initialize Socket.IO without user ID');
            return;
        }
        
        console.log('ðŸš€ Initializing Socket.IO connections for user:', userId);
        
        const socketOptions = {
            transports: ['polling'], // Start with polling only
            reconnection: true,
            reconnectionAttempts: Infinity,
            reconnectionDelay: 1000,
            reconnectionDelayMax: 5000,
            timeout: 20000,
            forceNew: true,
            path: '/socket.io/',
            rejectUnauthorized: false,
            extraHeaders: {
                'Authorization': `Bearer ${localStorage.getItem("sessionToken")}`
            },
            upgrade: false, // Disable upgrade initially
            rememberUpgrade: false,
            autoConnect: false
        };
        
        // Initialize Socket.IO connections with error handling
        try {
            // Create socket instances
            projectsSocket = io(`${wsUrl}/projects`, socketOptions);
            tasksSocket = io(`${wsUrl}/tasks`, socketOptions);
            usersSocket = io(`${wsUrl}/users`, socketOptions);
            commentsSocket = io(`${wsUrl}/comments`, socketOptions);
            notificationsSocket = io(`${wsUrl}/notifications`, socketOptions);
            
            let connectedSockets = 0;
            const totalSockets = 5; // Total number of socket connections
            
            // Add connection error handling
            [projectsSocket, tasksSocket, usersSocket, commentsSocket, notificationsSocket].forEach(socket => {
                socket.on('connect_error', (error) => {
                    console.error('Socket connection error:', error);
                    
                    // Handle specific error cases
                    if (error.message.includes('502')) {
                        console.log('Server error (502), retrying with polling...');
                        socket.io.opts.transports = ['polling'];
                        socket.io.opts.upgrade = false;
                        
                        // Try to reconnect with polling only
                        setTimeout(() => {
                            if (socket.disconnected) {
                                socket.connect();
                            }
                        }, 1000);
                    }
                    
                    showNotification("Connection Error", "Trying to reconnect...", "warning");
                    updateConnectionStatus(false);
                });

                socket.on('connect', () => {
                    console.log(`Connected to ${socket.nsp} namespace`);
                    connectedSockets++;
                    
                    // Update connection status based on number of connected sockets
                    if (connectedSockets === totalSockets) {
                        updateConnectionStatus(true);
                        showNotification("Connected", "All real-time connections established", "success");
                    }
                });

                socket.on('disconnect', (reason) => {
                    console.log(`Disconnected from ${socket.nsp}:`, reason);
                    connectedSockets--;
                    updateConnectionStatus(false);
                    
                    // Handle specific disconnect reasons
                    if (reason === 'io server disconnect' || reason === 'transport close') {
                        socket.io.opts.transports = ['polling'];
                        socket.io.opts.upgrade = false;
                        setTimeout(() => socket.connect(), 1000);
                    }
                    
                    showNotification("Connection Lost", "Attempting to reconnect...", "warning");
                });

                socket.on('reconnect_attempt', (attemptNumber) => {
                    console.log(`Reconnection attempt ${attemptNumber} for ${socket.nsp}`);
                    
                    // After 3 failed attempts, switch to polling only
                    if (attemptNumber >= 3) {
                        socket.io.opts.transports = ['polling'];
                        socket.io.opts.upgrade = false;
                    }
                });

                socket.on('reconnect', (attemptNumber) => {
                    console.log(`Reconnected to ${socket.nsp} after ${attemptNumber} attempts`);
                    connectedSockets++;
                    
                    if (connectedSockets === totalSockets) {
                        updateConnectionStatus(true);
                        showNotification("Reconnected", "All real-time connections restored", "success");
                    }
                });

                socket.on('reconnect_error', (error) => {
                    console.error(`Reconnection error for ${socket.nsp}:`, error);
                    updateConnectionStatus(false);
                    
                    // If reconnection fails, try polling only
                    socket.io.opts.transports = ['polling'];
                    socket.io.opts.upgrade = false;
                });

                socket.on('reconnect_failed', () => {
                    console.error(`Failed to reconnect to ${socket.nsp}`);
                    updateConnectionStatus(false);
                    showNotification("Connection Failed", "Please refresh the page", "error");
                });

                socket.on('ping_timeout', () => {
                    console.log(`Ping timeout for ${socket.nsp}, reconnecting...`);
                    updateConnectionStatus(false);
                    socket.io.opts.transports = ['polling'];
                    socket.io.opts.upgrade = false;
                    socket.connect();
                });
            });
            
            // Connect all sockets
            connectAndAuthenticateSockets();
            
        } catch (error) {
            console.error('Failed to initialize Socket.IO:', error);
            updateConnectionStatus(false);
            showNotification("Connection Error", "Failed to establish real-time connection", "error");
        }
    }

    function connectAndAuthenticateSockets() {
        // Ensure all sockets are connected
        function connectSocket(socket, namespace) {
            if (socket.disconnected) {
                console.log(`ðŸ”Œ Connecting to ${namespace} namespace...`);
                try {
                    // Start with polling transport
                    socket.io.opts.transports = ['polling'];
                    socket.io.opts.upgrade = false;
                    
                    socket.connect();
                    
                    // Add connection verification with timeout
                    const connectionTimeout = setTimeout(() => {
                        if (!socket.connected) {
                            console.error(`âŒ Failed to connect to ${namespace} namespace`);
                            updateConnectionStatus(false);
                            // Try to reconnect with polling
                            socket.io.opts.transports = ['polling'];
                            socket.io.opts.upgrade = false;
                            socket.connect();
                        }
                    }, 5000);

                    socket.once('connect', () => {
                        clearTimeout(connectionTimeout);
                        console.log(`âœ… Connected to ${namespace} namespace successfully`);
                    });
                } catch (error) {
                    console.error(`Error connecting to ${namespace}:`, error);
                    updateConnectionStatus(false);
                }
            } else {
                console.log(`âœ… Already connected to ${namespace} namespace`);
            }
        }
        
        // Connect all sockets
        connectSocket(projectsSocket, 'projects');
        connectSocket(tasksSocket, 'tasks');
        connectSocket(usersSocket, 'users');
        connectSocket(commentsSocket, 'comments');
        connectSocket(notificationsSocket, 'notifications');
        
        // Authenticate with user ID
        const auth = { 
            userId: localStorage.getItem('userId'),
            token: localStorage.getItem("sessionToken")
        };
        
        // Send authentication with retry
        function sendAuth(socket, namespace) {
            try {
                socket.emit('authenticate', auth, (response) => {
                    if (response && response.error) {
                        console.error(`Authentication failed for ${namespace}:`, response.error);
                        updateConnectionStatus(false);
                        // Retry authentication after delay
                        setTimeout(() => sendAuth(socket, namespace), 2000);
                    } else {
                        console.log(`âœ… Authenticated with ${namespace} namespace`);
                    }
                });
            } catch (error) {
                console.error(`Error authenticating with ${namespace}:`, error);
                updateConnectionStatus(false);
                setTimeout(() => sendAuth(socket, namespace), 2000);
            }
        }
        
        // Authenticate all sockets
        sendAuth(projectsSocket, 'projects');
        sendAuth(tasksSocket, 'tasks');
        sendAuth(usersSocket, 'users');
        sendAuth(commentsSocket, 'comments');
        sendAuth(notificationsSocket, 'notifications');
        
        // Subscribe to notifications
        notificationsSocket.emit('subscribe_user', localStorage.getItem('userId'));
    }

    // Update the existing connectWebSocket function to use Socket.IO
    function connectWebSocket() {
        if (currentUser) {
            initializeSocketIO();
            }
        }

    </script>
</body>
</html>